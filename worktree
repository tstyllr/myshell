#!/bin/bash

# Git Worktree Manager
# A shell script that replicates the functionality of the /worktree Claude Code command
# Manages multiple git worktrees in a .trees folder

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Function to print colored output
print_colored() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Function to check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_colored "$RED" "‚ùå Error: Not in a git repository."
        exit 1
    fi
}

# Function to parse branch:port format
parse_branch_port() {
    local input="$1"
    local branch=""
    local port=""
    
    if [[ "$input" == *":"* ]]; then
        branch="${input%:*}"
        port="${input#*:}"
        
        # Validate port number
        if [[ ! "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1024 ] || [ "$port" -gt 65535 ]; then
            print_colored "$RED" "‚ùå Invalid port: $port (must be between 1024-65535)"
            return 1
        fi
    else
        branch="$input"
        port=""
    fi
    
    echo "$branch|$port"
}

# Function to check if port is available
check_port_available() {
    local port="$1"

    if lsof -i :$port >/dev/null 2>&1; then
        return 1  # Port is in use
    else
        return 0  # Port is available
    fi
}

# Function to setup node_modules symbolic link for worktree
setup_node_modules_link() {
    local worktree_path="$1"
    local branch_name="$2"

    # Get absolute path to main project's node_modules
    local main_node_modules="$(pwd)/node_modules"

    # Check if main project has node_modules
    if [ ! -d "$main_node_modules" ]; then
        # Main project doesn't have node_modules, skip silently
        return 0
    fi

    # Get absolute path to worktree's node_modules location
    local worktree_node_modules="$(pwd)/$worktree_path/node_modules"

    # Check if worktree already has node_modules
    if [ -e "$worktree_node_modules" ]; then
        # If it's already a symlink, skip
        if [ -L "$worktree_node_modules" ]; then
            return 0
        fi
        # If it's a directory, preserve it (skip)
        if [ -d "$worktree_node_modules" ]; then
            return 0
        fi
    fi

    # Create symbolic link from worktree to main project's node_modules
    if ln -s "$main_node_modules" "$worktree_node_modules" 2>/dev/null; then
        print_colored "$CYAN" "üîó Linked node_modules from main project"
    fi
}

# Function to setup .claude and CLAUDE.md symbolic links for worktree
setup_claude_links() {
    local worktree_path="$1"
    local branch_name="$2"

    # Handle .claude directory
    local main_claude_dir="$(pwd)/.claude"
    if [ -d "$main_claude_dir" ]; then
        local worktree_claude_dir="$(pwd)/$worktree_path/.claude"
        if [ ! -e "$worktree_claude_dir" ]; then
            if ln -s "$main_claude_dir" "$worktree_claude_dir" 2>/dev/null; then
                print_colored "$CYAN" "üîó Linked .claude directory from main project"
            fi
        fi
    fi

    # Handle CLAUDE.md file
    local main_claude_md="$(pwd)/CLAUDE.md"
    if [ -f "$main_claude_md" ]; then
        local worktree_claude_md="$(pwd)/$worktree_path/CLAUDE.md"
        if [ ! -e "$worktree_claude_md" ]; then
            if ln -s "$main_claude_md" "$worktree_claude_md" 2>/dev/null; then
                print_colored "$CYAN" "üîó Linked CLAUDE.md from main project"
            fi
        fi
    fi
}

# Function to get next available port starting from given port
get_next_available_port() {
    local start_port="$1"
    local port="$start_port"
    
    while ! check_port_available "$port"; do
        ((port++))
        if [ "$port" -gt 65535 ]; then
            print_colored "$RED" "‚ùå No available ports found starting from $start_port"
            return 1
        fi
    done
    
    echo "$port"
}

# Function to check if a branch has unmerged commits compared to base branch
check_unmerged_commits() {
    local target_branch="$1"
    local base_branch="$2"
    
    if [ -z "$target_branch" ] || [ -z "$base_branch" ]; then
        return 1
    fi
    
    # Check if both branches exist
    if ! git show-ref --verify --quiet refs/heads/"$target_branch"; then
        return 1
    fi
    
    if ! git show-ref --verify --quiet refs/heads/"$base_branch"; then
        return 1
    fi
    
    # Get count of unmerged commits (commits in target_branch but not in base_branch)
    local unmerged_count
    unmerged_count=$(git rev-list "$base_branch".."$target_branch" --count 2>/dev/null)
    
    if [ "$unmerged_count" -gt 0 ]; then
        print_colored "$YELLOW" "‚ö†Ô∏è  Branch '$target_branch' has $unmerged_count unmerged commit(s):"
        echo "   Recent unmerged commits:"
        git log "$base_branch".."$target_branch" --oneline -5 2>/dev/null | sed 's/^/     ‚Ä¢ /'
        if [ "$unmerged_count" -gt 5 ]; then
            echo "     ... and $((unmerged_count - 5)) more commit(s)"
        fi
        echo
        return 1  # Has unmerged commits
    fi
    
    return 0  # No unmerged commits, safe to delete
}

# Function to show help
show_help() {
    echo "Git Worktree Manager"
    echo
    echo "USAGE:"
    echo "  $0 [COMMAND] [ARGUMENTS]"
    echo
    echo "COMMANDS:"
    echo "  list                         List all worktrees"
    echo "  create <branch1,branch2>     Create worktrees for specified branches"
    echo "  start <branch1[:port1],..>   Create, run, and open worktrees (supports port specification)"
    echo "  open [branch1,branch2]       Open all or specified worktrees in VS Code"
    echo "  remove [branch1,branch2] [--force]    Remove all or specified worktrees (with safety check)"
    echo "  merge [branch1,branch2]      Merge all or specified worktrees into current branch"
    echo "  run <branch1[:port1],..>     Run npm dev server for worktrees (supports port specification)"
    echo "  help                         Show this help message"
    echo
    echo "EXAMPLES:"
    echo "  $0 list"
    echo "  $0 create hotfix,dev,feature"
    echo "  $0 start dev,feature,hotfix"
    echo "  $0 start dev:3000,staging:3001,feature:3005"
    echo "  $0 start dev:3000,staging,feature"
    echo "  $0 open"
    echo "  $0 open dev,hotfix,feature"
    echo "  $0 remove"
    echo "  $0 remove dev,hotfix"
    echo "  $0 remove --force"
    echo "  $0 remove dev,hotfix --force"
    echo "  $0 merge"
    echo "  $0 merge feature,hotfix"
    echo "  $0 run foo:3000,bar:3001"
    echo "  $0 run dev:3000,staging"
    echo
    echo "DESCRIPTION:"
    echo "  This script manages git worktrees in a .trees folder, allowing you to work"
    echo "  on multiple branches simultaneously without switching between them."
    echo ""
    echo "SAFETY FEATURES:"
    echo "  ‚Ä¢ Remove operations check for unmerged commits before deletion"
    echo "  ‚Ä¢ Shows detailed information about commits that would be lost"
    echo "  ‚Ä¢ Prevents accidental data loss by requiring explicit confirmation"
    echo "  ‚Ä¢ Use --force to bypass safety checks (DANGEROUS: may lose work!)"
    echo ""
    echo "PORT SPECIFICATION:"
    echo "  Use branch:port format to specify custom ports (1024-65535):"
    echo "  ‚Ä¢ branch:3000         - Run on port 3000"
    echo "  ‚Ä¢ branch1:3000,branch2 - Mixed: branch1 on port 3000, branch2 auto-assigned"
    echo "  ‚Ä¢ If port is occupied, next available port will be used automatically"
}

# Function to list all worktrees
list_worktrees() {
    worktree_output=$(git worktree list 2>/dev/null)

    if [ -z "$worktree_output" ]; then
        echo ""
        exit 0
    fi

    worktree_names=()

    while IFS= read -r line; do
        path=$(echo "$line" | awk '{print $1}')

        if [[ "$path" == *"/.trees/"* ]]; then
            branch_name=$(basename "$path")
            worktree_names+=("$branch_name")
        fi
    done <<< "$worktree_output"

    # Output comma-separated names
    if [ ${#worktree_names[@]} -gt 0 ]; then
        IFS=',' ; echo "${worktree_names[*]}"
    else
        echo ""
    fi
}

# Function to create worktrees
create_worktrees() {
    local branches="$1"
    
    if [ -z "$branches" ]; then
        print_colored "$RED" "‚ùå Error: No branches specified for creation."
        echo "Usage: $0 create branch1,branch2,branch3"
        exit 1
    fi
    
    print_colored "$GREEN" "üå≥ Creating worktrees for branches: $branches"
    mkdir -p .trees
    
    IFS=',' read -ra BRANCHES <<< "$branches"
    created_count=0
    
    for branch in "${BRANCHES[@]}"; do
        branch=$(echo "$branch" | xargs)
        echo "Creating worktree for branch: $branch"
        
        if git show-ref --verify --quiet refs/heads/"$branch"; then
            echo "Branch $branch exists locally"
            if git worktree add .trees/"$branch" "$branch" 2>/dev/null; then
                print_colored "$GREEN" "‚úÖ Worktree created at .trees/$branch"
                setup_node_modules_link ".trees/$branch" "$branch"
                setup_claude_links ".trees/$branch" "$branch"
                ((created_count++))
            else
                print_colored "$YELLOW" "‚ö†Ô∏è  Worktree for $branch may already exist"
            fi
        else
            echo "Branch $branch does not exist locally, creating new branch"
            if git worktree add -b "$branch" .trees/"$branch" 2>/dev/null; then
                print_colored "$GREEN" "‚úÖ New branch and worktree created at .trees/$branch"
                setup_node_modules_link ".trees/$branch" "$branch"
                setup_claude_links ".trees/$branch" "$branch"
                ((created_count++))
            else
                print_colored "$RED" "‚ùå Failed to create worktree for $branch"
            fi
        fi
        echo "---"
    done
    
    print_colored "$GREEN" "‚úÖ Worktree creation completed! ($created_count worktrees created)"
}

# Function to remove worktrees
remove_worktrees() {
    local branches="$1"
    local force_remove="$2"
    
    if [ ! -d ".trees" ]; then
        print_colored "$RED" "‚ùå No .trees directory found. Nothing to remove."
        exit 0
    fi
    
    current_branch=$(git branch --show-current)
    echo "Current branch: $current_branch"
    
    if [ -z "$branches" ]; then
        print_colored "$YELLOW" "üóëÔ∏è  Removing all worktrees and associated branches..."
        
        # Pre-check: collect branches with unmerged commits
        branches_with_unmerged=()
        if [ "$force_remove" != "true" ]; then
            for worktree_dir in .trees/*/; do
                if [ -d "$worktree_dir" ]; then
                    branch_name=$(basename "$worktree_dir")
                    if [ "$branch_name" != "$current_branch" ]; then
                        if ! check_unmerged_commits "$branch_name" "$current_branch"; then
                            branches_with_unmerged+=("$branch_name")
                        fi
                    fi
                fi
            done
            
            # If there are unmerged branches, warn user
            if [ ${#branches_with_unmerged[@]} -gt 0 ]; then
                print_colored "$RED" "üö® DANGER: The following branches have unmerged commits:"
                for branch in "${branches_with_unmerged[@]}"; do
                    echo "  ‚Ä¢ $branch"
                done
                echo
                print_colored "$YELLOW" "These changes will be lost if you proceed!"
                echo "Options:"
                echo "  1. Cancel and merge these branches first: git merge <branch_name>"
                echo "  2. Force delete anyway: $0 remove --force"
                echo
                print_colored "$RED" "‚ùå Operation cancelled to prevent data loss."
                exit 1
            fi
        fi
        
        removed_count=0
        for worktree_dir in .trees/*/; do
            if [ -d "$worktree_dir" ]; then
                branch_name=$(basename "$worktree_dir")
                echo "Removing worktree: $branch_name"
                
                git worktree remove "$worktree_dir" --force 2>/dev/null || true
                
                if [ "$branch_name" != "main" ] && [ "$branch_name" != "master" ] && [ "$branch_name" != "$current_branch" ]; then
                    echo "Deleting branch: $branch_name"
                    git branch -D "$branch_name" 2>/dev/null || true
                else
                    echo "Keeping protected branch: $branch_name"
                fi
                ((removed_count++))
                echo "---"
            fi
        done
        
        rm -rf .trees
        print_colored "$GREEN" "‚úÖ All worktrees ($removed_count) and branches removed successfully!"
    else
        print_colored "$YELLOW" "üóëÔ∏è  Removing specified worktrees: $branches"
        
        IFS=',' read -ra REQUESTED_BRANCHES <<< "$branches"
        
        # Pre-check: collect branches with unmerged commits
        branches_with_unmerged=()
        if [ "$force_remove" != "true" ]; then
            for branch in "${REQUESTED_BRANCHES[@]}"; do
                branch=$(echo "$branch" | xargs)
                if [ -d ".trees/$branch" ] && [ "$branch" != "$current_branch" ]; then
                    if ! check_unmerged_commits "$branch" "$current_branch"; then
                        branches_with_unmerged+=("$branch")
                    fi
                fi
            done
            
            # If there are unmerged branches, warn user
            if [ ${#branches_with_unmerged[@]} -gt 0 ]; then
                print_colored "$RED" "üö® DANGER: The following branches have unmerged commits:"
                for branch in "${branches_with_unmerged[@]}"; do
                    echo "  ‚Ä¢ $branch"
                done
                echo
                print_colored "$YELLOW" "These changes will be lost if you proceed!"
                echo "Options:"
                echo "  1. Cancel and merge these branches first: git merge <branch_name>"
                echo "  2. Force delete anyway: $0 remove $branches --force"
                echo
                print_colored "$RED" "‚ùå Operation cancelled to prevent data loss."
                exit 1
            fi
        fi
        
        removed_count=0
        skipped_count=0
        
        for branch in "${REQUESTED_BRANCHES[@]}"; do
            branch=$(echo "$branch" | xargs)
            
            if [ -d ".trees/$branch" ]; then
                echo "Removing worktree: $branch"
                
                git worktree remove ".trees/$branch" --force 2>/dev/null || true
                
                if [ "$branch" != "main" ] && [ "$branch" != "master" ] && [ "$branch" != "$current_branch" ]; then
                    echo "Deleting branch: $branch"
                    git branch -D "$branch" 2>/dev/null || true
                else
                    echo "Keeping protected branch: $branch"
                fi
                ((removed_count++))
            else
                print_colored "$YELLOW" "‚ö†Ô∏è  Worktree not found for branch: $branch (skipping)"
                ((skipped_count++))
            fi
            echo "---"
        done
        
        if [ -z "$(ls -A .trees 2>/dev/null)" ]; then
            rm -rf .trees
            print_colored "$CYAN" "üßπ Cleaned up empty .trees directory"
        fi
        
        print_colored "$BLUE" "üìä Remove Summary:"
        echo "  ‚úÖ Removed worktrees: $removed_count"
        echo "  ‚è≠Ô∏è  Skipped (not found): $skipped_count"
        print_colored "$GREEN" "‚úÖ Specified worktrees removal completed!"
    fi
}

# Function to open worktrees in VS Code
open_worktrees() {
    local branches="$1"
    
    if [ ! -d ".trees" ]; then
        print_colored "$RED" "‚ùå No .trees directory found. No worktrees to open."
        exit 0
    fi
    
    if [ -z "$branches" ]; then
        print_colored "$CYAN" "üöÄ Opening all worktrees in VS Code..."
        
        opened_count=0
        for worktree_dir in .trees/*/; do
            if [ -d "$worktree_dir" ]; then
                branch_name=$(basename "$worktree_dir")
                echo "Opening worktree: $branch_name"
                
                if command -v code >/dev/null 2>&1; then
                    code "$worktree_dir"
                    print_colored "$GREEN" "‚úÖ Opened .trees/$branch_name in VS Code"
                    ((opened_count++))
                else
                    print_colored "$RED" "‚ùå VS Code command 'code' not found. Please install VS Code CLI."
                    exit 1
                fi
                echo "---"
            fi
        done
        
        print_colored "$GREEN" "‚úÖ All worktrees ($opened_count) opened in VS Code!"
    else
        print_colored "$CYAN" "üöÄ Opening specified worktrees in VS Code: $branches"
        
        IFS=',' read -ra REQUESTED_BRANCHES <<< "$branches"
        opened_count=0
        not_found_count=0
        
        for branch in "${REQUESTED_BRANCHES[@]}"; do
            branch=$(echo "$branch" | xargs)
            
            if [ -d ".trees/$branch" ]; then
                echo "Opening worktree: $branch"
                
                if command -v code >/dev/null 2>&1; then
                    code ".trees/$branch"
                    print_colored "$GREEN" "‚úÖ Opened .trees/$branch in VS Code"
                    ((opened_count++))
                else
                    print_colored "$RED" "‚ùå VS Code command 'code' not found. Please install VS Code CLI."
                    exit 1
                fi
            else
                print_colored "$YELLOW" "‚ö†Ô∏è  Worktree not found for branch: $branch (skipping)"
                ((not_found_count++))
            fi
            echo "---"
        done
        
        print_colored "$BLUE" "üìä Open Summary:"
        echo "  ‚úÖ Opened in VS Code: $opened_count"
        echo "  ‚è≠Ô∏è  Not found (skipped): $not_found_count"
        print_colored "$GREEN" "‚úÖ Specified worktrees opening completed!"
    fi
}

# Function to merge worktrees
merge_worktrees() {
    local branches="$1"
    
    if [ ! -d ".trees" ]; then
        print_colored "$RED" "‚ùå No .trees directory found. No worktrees to merge."
        exit 0
    fi
    
    current_branch=$(git branch --show-current)
    echo "Current branch: $current_branch"
    
    if [ -z "$branches" ]; then
        print_colored "$CYAN" "üîÄ Merging all worktree branches into current branch..."
        
        branches_to_merge=()
        for worktree_dir in .trees/*/; do
            if [ -d "$worktree_dir" ]; then
                branch_name=$(basename "$worktree_dir")
                if [ "$branch_name" != "$current_branch" ]; then
                    branches_to_merge+=("$branch_name")
                fi
            fi
        done
    else
        print_colored "$CYAN" "üîÄ Merging specified worktree branches into current branch: $branches"
        
        IFS=',' read -ra REQUESTED_BRANCHES <<< "$branches"
        branches_to_merge=()
        for branch in "${REQUESTED_BRANCHES[@]}"; do
            branch=$(echo "$branch" | xargs)
            if [ -d ".trees/$branch" ] && [ "$branch" != "$current_branch" ]; then
                branches_to_merge+=("$branch")
            elif [ "$branch" = "$current_branch" ]; then
                print_colored "$YELLOW" "‚è≠Ô∏è  Skipping current branch: $branch"
            else
                print_colored "$YELLOW" "‚ö†Ô∏è  Worktree not found for branch: $branch (skipping)"
            fi
        done
    fi
    
    if [ ${#branches_to_merge[@]} -eq 0 ]; then
        print_colored "$RED" "‚ùå No branches found to merge (or all branches are the same as current branch)."
        exit 0
    fi
    
    echo "Found branches to merge: ${branches_to_merge[*]}"
    echo "---"
    
    merge_success=0
    merge_conflicts=0
    for branch in "${branches_to_merge[@]}"; do
        echo "Merging branch: $branch"
        
        if git merge "$branch" --no-edit; then
            print_colored "$GREEN" "‚úÖ Successfully merged: $branch"
            ((merge_success++))
        else
            print_colored "$YELLOW" "‚ö†Ô∏è  Merge conflict detected for: $branch"
            echo "Please resolve conflicts manually and commit, then run the merge command again."
            ((merge_conflicts++))
            git merge --abort 2>/dev/null || true
        fi
        echo "---"
    done
    
    print_colored "$BLUE" "üìä Merge Summary:"
    echo "  ‚úÖ Successful merges: $merge_success"
    echo "  ‚ö†Ô∏è  Conflicts encountered: $merge_conflicts"
    
    if [ $merge_conflicts -eq 0 ]; then
        print_colored "$GREEN" "üéâ All specified branches merged successfully!"
    else
        print_colored "$YELLOW" "‚ö†Ô∏è  Some merges had conflicts. Please resolve them manually."
    fi
}

# Function to start worktrees (create + run + open)
start_worktrees() {
    local branches="$1"
    
    if [ -z "$branches" ]; then
        print_colored "$RED" "‚ùå Error: No branches specified for starting."
        echo "Usage: $0 start branch1[:port1],branch2[:port2],branch3"
        echo "Examples:"
        echo "  $0 start dev,staging,feature"
        echo "  $0 start dev:3000,staging:3001"
        echo "  $0 start dev:3000,staging,feature:3005"
        exit 1
    fi
    
    print_colored "$CYAN" "üöÄ Starting worktrees for branches: $branches"
    echo "This will create, run, and open the specified worktrees..."
    echo "---"
    
    # Step 1: Create worktrees (extract branch names only)
    print_colored "$BLUE" "Step 1: Creating worktrees..."
    
    # Extract branch names from branch:port format
    IFS=',' read -ra REQUESTED_BRANCHES <<< "$branches"
    pure_branches=()
    
    for branch_input in "${REQUESTED_BRANCHES[@]}"; do
        branch_input=$(echo "$branch_input" | xargs)
        parsed=$(parse_branch_port "$branch_input")
        if [ $? -eq 0 ]; then
            branch="${parsed%|*}"
            pure_branches+=("$branch")
        fi
    done
    
    # Join pure branch names with commas
    pure_branches_str=$(IFS=','; echo "${pure_branches[*]}")
    create_worktrees "$pure_branches_str"
    echo
    
    # Step 2: Run worktrees in terminal windows
    print_colored "$BLUE" "Step 2: Starting development servers..."
    run_worktrees "$branches"
    echo
    
    # Step 3: Open worktrees in VS Code
    print_colored "$BLUE" "Step 3: Opening in VS Code..."
    open_worktrees "$pure_branches_str"
    echo
    
    print_colored "$GREEN" "üéâ All worktrees have been started successfully!"
    print_colored "$CYAN" "üí° Next steps:"
    echo "  ‚Ä¢ Check your terminal windows for development servers"
    echo "  ‚Ä¢ VS Code windows should be opening automatically"
    echo "  ‚Ä¢ Use 'worktree list' to see all active worktrees"
}

# Function to run worktrees in new terminal windows
run_worktrees() {
    local branches="$1"
    
    if [ -z "$branches" ]; then
        print_colored "$RED" "‚ùå Error: No branches specified for running."
        echo "Usage: $0 run branch1[:port1],branch2[:port2],branch3"
        echo "Examples:"
        echo "  $0 run dev:3000,staging:3001"
        echo "  $0 run dev:3000,staging,feature:3005"
        exit 1
    fi
    
    if [ ! -d ".trees" ]; then
        print_colored "$RED" "‚ùå No .trees directory found. No worktrees to run."
        exit 0
    fi
    
    print_colored "$CYAN" "üöÄ Starting npm dev servers for specified worktrees: $branches"
    
    IFS=',' read -ra REQUESTED_BRANCHES <<< "$branches"
    started_count=0
    not_found_count=0
    auto_port=3000
    
    for branch_input in "${REQUESTED_BRANCHES[@]}"; do
        branch_input=$(echo "$branch_input" | xargs)
        
        # Parse branch and port
        parsed=$(parse_branch_port "$branch_input")
        if [ $? -ne 0 ]; then
            print_colored "$RED" "‚ùå Failed to parse: $branch_input"
            ((not_found_count++))
            continue
        fi
        
        branch="${parsed%|*}"
        specified_port="${parsed#*|}"
        
        if [ -d ".trees/$branch" ]; then
            # Determine port to use
            if [ -n "$specified_port" ]; then
                # Use specified port, check if available
                if check_port_available "$specified_port"; then
                    use_port="$specified_port"
                    print_colored "$BLUE" "üîå Using specified port $use_port for $branch"
                else
                    print_colored "$YELLOW" "‚ö†Ô∏è  Port $specified_port is in use, finding next available port..."
                    use_port=$(get_next_available_port "$specified_port")
                    if [ $? -ne 0 ]; then
                        print_colored "$RED" "‚ùå Cannot find available port for $branch"
                        ((not_found_count++))
                        continue
                    fi
                    print_colored "$BLUE" "üîå Using alternative port $use_port for $branch"
                fi
            else
                # Auto-assign port
                use_port=$(get_next_available_port "$auto_port")
                if [ $? -ne 0 ]; then
                    print_colored "$RED" "‚ùå Cannot find available port for $branch"
                    ((not_found_count++))
                    continue
                fi
                auto_port=$((use_port + 1))
                print_colored "$BLUE" "üîå Auto-assigned port $use_port for $branch"
            fi
            
            echo "Starting worktree: $branch on port $use_port"
            
            # Get absolute path to worktree
            worktree_path=$(pwd)/.trees/$branch
            
            # Open new terminal window and run npm commands
            osascript -e "
            tell application \"Terminal\"
                do script \"cd '$worktree_path' && echo 'Starting development server on port $use_port...' && npm run dev -- -p $use_port\"
                set custom title of front window to \"$branch:$use_port\"
                set title displays custom title of front window to true
                activate
            end tell
            "
            
            print_colored "$GREEN" "‚úÖ Started $branch on port $use_port in new terminal window"
            ((started_count++))
        else
            print_colored "$YELLOW" "‚ö†Ô∏è  Worktree not found for branch: $branch (skipping)"
            ((not_found_count++))
        fi
        echo "---"
    done
    
    print_colored "$BLUE" "üìä Run Summary:"
    echo "  ‚úÖ Started in terminal: $started_count"
    echo "  ‚è≠Ô∏è  Not found (skipped): $not_found_count"
    print_colored "$GREEN" "‚úÖ Worktree run command completed!"
}

# Main function
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 1
    fi
    
    check_git_repo
    
    case "$1" in
        "list")
            list_worktrees
            ;;
        "create")
            create_worktrees "$2"
            ;;
        "start")
            start_worktrees "$2"
            ;;
        "open")
            open_worktrees "$2"
            ;;
        "remove")
            # Parse --force option
            force_flag="false"
            branches_arg="$2"
            
            # Check if --force is in $2 or $3
            if [ "$2" = "--force" ]; then
                force_flag="true"
                branches_arg="$3"
            elif [ "$3" = "--force" ]; then
                force_flag="true"
                branches_arg="$2"
            fi
            
            remove_worktrees "$branches_arg" "$force_flag"
            ;;
        "merge")
            merge_worktrees "$2"
            ;;
        "run")
            run_worktrees "$2"
            ;;
        "help"|"-h"|"--help")
            show_help
            ;;
        *)
            if [[ "$1" != *","* ]]; then
                print_colored "$RED" "‚ùå Unknown command: $1"
                echo
                show_help
                exit 1
            else
                # Assume it's branch list for creation
                create_worktrees "$1"
            fi
            ;;
    esac
}

# Run the main function with all arguments
main "$@"